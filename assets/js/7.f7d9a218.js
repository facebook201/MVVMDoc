(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{177:function(e,t,a){"use strict";a.r(t);var s=a(0),_=Object(s.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("div",{staticClass:"content"},[a("h1",{attrs:{id:"react-源码"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-源码","aria-hidden":"true"}},[e._v("#")]),e._v(" React 源码")]),e._v(" "),a("h2",{attrs:{id:"理念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#理念","aria-hidden":"true"}},[e._v("#")]),e._v(" 理念")]),e._v(" "),a("p",[e._v("React 的 调用栈分三个层次")]),e._v(" "),a("ul",[a("li",[e._v("Scheduler（调度器）—— 调度任务的优先级，高优任务优先进入"),a("strong",[e._v("Reconciler")])]),e._v(" "),a("li",[e._v("Reconciler（协调器）—— 负责找出变化的组件")]),e._v(" "),a("li",[e._v("Renderer（渲染器）  —— 负责将变化的组件渲染到页面上")])]),e._v(" "),a("p",[a("strong",[e._v("React意在 构建快速响应的大型Web应用程序。所以最重要的问题就是解决 CPU 和 IO 的瓶颈问题。也就是新版的并发的更新模式代替以前的同步更新模式。Fiber架构能实现并发更新。")])]),e._v(" "),a("h2",{attrs:{id:"源码学习三个阶段"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#源码学习三个阶段","aria-hidden":"true"}},[e._v("#")]),e._v(" 源码学习三个阶段")]),e._v(" "),a("ul",[a("li",[e._v("首先从 Build you Own React [https://pomb.us/build-your-own-react/]")]),e._v(" "),a("li",[e._v("熟悉到 React的理念")]),e._v(" "),a("li",[e._v("参考别人的React源码解析")]),e._v(" "),a("li",[e._v("自己从头到尾认真的读一遍")])]),e._v(" "),a("h2",{attrs:{id:"fiber-架构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#fiber-架构","aria-hidden":"true"}},[e._v("#")]),e._v(" Fiber 架构")]),e._v(" "),a("h2",{attrs:{id:"定义"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#定义","aria-hidden":"true"}},[e._v("#")]),e._v(" 定义")]),e._v(" "),a("p",[e._v("React Hook 从具象来说就为函数组件（纯函数）提供副作用能力的 React API，确定状态源的解决方案。")]),e._v(" "),a("ul",[a("li",[e._v("在组件之间复用状态逻辑很难（高阶组件、render props 代码难以理解 嵌套深）")]),e._v(" "),a("li",[e._v("复杂组件难以理解")]),e._v(" "),a("li",[e._v("class 难以理解 this指向")])]),e._v(" "),a("h2",{attrs:{id:"hook-是如何保存数据"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hook-是如何保存数据","aria-hidden":"true"}},[e._v("#")]),e._v(" Hook 是如何保存数据")]),e._v(" "),a("p",[e._v("FC 的 render 本身只是函数调用，"),a("strong",[e._v("每个组件都有对应的 fiber 节点（可以理解为虚拟DOM），用于保存组件相关信息，每次组件 Render时，全局变量"),a("code",[e._v("currentlyRenderingFiber")]),e._v("都会被赋值为该"),a("code",[e._v("FunctionComponent")]),e._v("对应的"),a("code",[e._v("fiber节点")]),e._v("。")]),e._v(" 所以 hook 内部其实是从 currentlyRenderingFiber 中获取状态信息的。")]),e._v(" "),a("h2",{attrs:{id:"多个是怎么保存的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#多个是怎么保存的","aria-hidden":"true"}},[e._v("#")]),e._v(" 多个是怎么保存的")]),e._v(" "),a("p",[a("code",[e._v("currentlyRenderingFiber.memoizedState")]),e._v("中保存一条"),a("code",[e._v("hook")]),e._v("对应数据的单向链表。")]),e._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("const")]),e._v(" HookA "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// hook 保存的数据")]),e._v("\n    memoizedState"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// 下一个hook")]),e._v("\n    next"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" hookB"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// 本次更新开始时已经有 update队列")]),e._v("\n    baseState"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// 本次更新开始有 update 队列")]),e._v("\n    baseQueue"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// 本次更新需要增加的 update 队列")]),e._v("\n    queue"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("null")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\nhookB"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("next "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" hookC"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\ncurrentlyRenderingFiber"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("memoizedState "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" hookA"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])])]),a("p",[e._v("当"),a("code",[e._v("FunctionComponent")]),e._v(" "),a("code",[e._v("render")]),e._v("时，每执行到一个"),a("code",[e._v("hook")]),e._v("，都会将指向"),a("code",[e._v("currentlyRenderingFiber.memoizedState")]),e._v("链表的指针向后移动一次，指向当前"),a("code",[e._v("hook")]),e._v("对应数据。")]),e._v(" "),a("p",[e._v("这也是为什么"),a("code",[e._v("React")]),e._v("要求"),a("code",[e._v("hook")]),e._v("的调用顺序不能改变（不能在条件语句中使用"),a("code",[e._v("hook")]),e._v("） —— 每次"),a("code",[e._v("render")]),e._v("时都是从一条固定顺序的链表中获取"),a("code",[e._v("hook")]),e._v("对应数据的。")]),e._v(" "),a("h2",{attrs:{id:"usestate-执行流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#usestate-执行流程","aria-hidden":"true"}},[e._v("#")]),e._v(" useState 执行流程")]),e._v(" "),a("p",[a("code",[e._v("useState")]),e._v("返回值数组第二个参数为"),a("strong",[e._v("改变state的方法")]),e._v("。")]),e._v(" "),a("p",[e._v("在源码中，他被称为"),a("code",[e._v("dispatchAction")]),e._v("。每当调用"),a("code",[e._v("dispatchAction")]),e._v("，都会创建一个代表一次更新的对象"),a("code",[e._v("update")]),e._v(" 如果是多次， "),a("code",[e._v("update")]),e._v("会形成一条环状链表。"),a("code",[e._v("update")]),e._v("链表是由某个"),a("code",[e._v("useState")]),e._v("的"),a("code",[e._v("dispatchAction")]),e._v("产生，那么这条链表显然属于该"),a("code",[e._v("useState hook")]),e._v("。")]),e._v(" "),a("p",[e._v("其中，"),a("code",[e._v("queue")]),e._v("中保存了本次更新"),a("code",[e._v("update")]),e._v("的链表。")]),e._v(" "),a("p",[e._v("在计算"),a("code",[e._v("state")]),e._v("时，会将"),a("code",[e._v("queue")]),e._v("的环状链表剪开挂载在"),a("code",[e._v("baseQueue")]),e._v("最后面，"),a("code",[e._v("baseQueue")]),e._v("基于"),a("code",[e._v("baseState")]),e._v("计算新的"),a("code",[e._v("state")]),e._v("。")]),e._v(" "),a("p",[e._v("在计算"),a("code",[e._v("state")]),e._v("完成后，新的"),a("code",[e._v("state")]),e._v("会成为"),a("code",[e._v("memoizedState")]),e._v("。")]),e._v(" "),a("blockquote",[a("p",[e._v("为什么更新不基于"),a("code",[e._v("memoizedState")]),e._v("而是"),a("code",[e._v("baseState")]),e._v("，是因为"),a("code",[e._v("state")]),e._v("的计算过程需要考虑优先级，可能有些"),a("code",[e._v("update")]),e._v("优先级不够被跳过。所以"),a("code",[e._v("memoizedState")]),e._v("并不一定和"),a("code",[e._v("baseState")]),e._v("相同。")])])])}],!1,null,null,null);t.default=_.exports}}]);